from fastmcp import FastMCP
from pydantic import Field
import requests
import os
from platforms import Platform
from query import INTROSPECTION_QUERY, IDENTITY_QUERY
from dotenv import load_dotenv
from typing import Annotated, Dict
from schema import SchemaInfo
load_dotenv()

mcp = FastMCP(name="relate-account")

url = os.getenv("DATA_API_URL", "https://graph.web3.bio/graphql")
schemas: Dict[str, SchemaInfo] = {}

def execute_graphql_query(query_obj: dict, url: str, timeout: int = 10000) -> dict:
	headers = {
		"Content-Type": "application/json",
		"User-Agent": "relate-account-mcp/3.0.0",
	}
	access_token = os.getenv("ACCESS_TOKEN")
	if access_token:
		headers["Authorization"] = access_token
	try:
		response = requests.post(
			url,
			json=query_obj,
			headers=headers,
			timeout=timeout
		)
		if not response.ok:
			raise Exception(f"HTTP {response.status_code}: {response.reason}")
		json_data = response.json()
		if "errors" in json_data:
			raise Exception(
				"GraphQL errors: " + ", ".join(e.get("message", str(e)) for e in json_data["errors"])
			)
		return json_data.get("data", {})
	except Exception as e:
		return {"error": f"Query failed: {e}"}
	
@mcp.tool(
	name="discover-query-schema",
	description="Discover the query schema for the given endpoint, the given endpoint is provided by web3.bio which is used as a crypto-related identity graph service provider. Users can use web3.bio to query all identity information of a specific platform identity. You should first use this tool to discover the query schema for the given endpoint to help build the query statement before you execute the query.",
)
def discover_query_schema() -> str:
	query_obj = {
		"query": INTROSPECTION_QUERY,
	}
	data = execute_graphql_query(query_obj, url)
	schemas["web3.bio"] = SchemaInfo("web3.bio", url, data)
	return str(data)

@mcp.tool(
	name="analyze-schema",
	description="Analyze the schema of the given endpoint, the given endpoint is provided by web3.bio which is used as a crypto-related identity graph service provider. This tool will be used to parse the fetched schema data and formalize it into a standard format for future use (etc. build query statement and execute the query).",
)
def analyze_schema() -> str:
	schema_info = schemas["web3.bio"]

	types = schema_info.schema.get("__schema", {}).get("types", [])
	# Filter out internal types
	filtered_types = [t for t in types if not t.get("name", "").startswith("__")]
	
	analysis = {
		"schema_name": "web3.bio",
		"endpoint": schema_info.endpoint,
		"type_count": len(filtered_types),
		"object_types": [t.get("name") for t in filtered_types if t.get("kind") == "OBJECT"],
		"scalar_types": [t.get("name") for t in filtered_types if t.get("kind") == "SCALAR"],
		"enum_types": [t.get("name") for t in filtered_types if t.get("kind") == "ENUM"],
	}
	return str(analysis)

@mcp.tool(
	name="execute-query",
	description="Execute the query statement for the given endpoint, the given endpoint is provided by web3.bio which is used as a crypto-related identity graph service provider. This tool will be used to execute the query statement for the given endpoint based on the schema analysis result.",
)
def execute_query(
	query_statement: Annotated[str, Field(description="The query statement to execute, which is generated by the graphql_agent.")]
) -> str:
	"""
	执行 GraphQL 查询语句
	
	Args:
		query_statement: 从 graphql_agent 传来的查询语句
		
	Returns:
		查询结果的字符串表示
	"""
	try:
		# 构建查询对象
		query_obj = {
			"query": query_statement
		}
		
		# 执行 GraphQL 查询
		result = execute_graphql_query(query_obj, url)
		
		# 检查是否有错误
		if "error" in result:
			return f"查询执行失败: {result['error']}"
		
		# 返回查询结果
		return str(result)
		
	except Exception as e:
		return f"执行查询时发生错误: {str(e)}"

if __name__ == "__main__":
	mcp.run(transport="http", host="127.0.0.1", port=8000, path="/mcp")
  
	
	